################################################################################
# TARGETS
#
# [R]: Single value variable can be redefined in other makefiles
# [+]: Values can be added to the variable in other makefiles
# [X]: Variable must not be redefined nor values be added to it
################################################################################
ifneq ($(PROJECT_TYPE),$(findstring $(PROJECT_TYPE),header program shared static))
    $(error PROJECT_TYPE must be one of [header, program, shared, static])
endif

# Build project and tests(if there is a test folder)
.PHONY: all
all:: $(PROJECT_DEPS) $(PROJECT_TYPE) $(TEST_TARGET)

# Compile *.c files
$(OBJ_PATH)/%.o: %.c $(OBJ_DEPS)
	$(COMPILE)

# Analyze code with various tools
.PHONY: analyze
analyze:: | $(SCANBUILD_PATH) $(CPPCHECK_PATH)
	$(SCANBUILD)
	$(CPPCHECK)

# Run tests(they must be build first)
.PHONY: check
check::
	$(MAKE) -C $(TEST_PATH) run BUILD_MODE=$(BUILD_MODE) \
	MAKEFILE_PATH=../$(MAKEFILE_PATH)

# Remove build files
ifneq ($(TEST_TARGET),empty_target)
CLEAN_TEST := clean_test
endif
CLEAN_CMD := rm -rf build
.PHONY: clean
clean:: $(CLEAN_TEST)
	$(CLEAN_CMD)

# Remove test build files
.PHONY: clean_test
clean_test::
	$(MAKE) -C $(TEST_PATH) clean MAKEFILE_PATH=../$(MAKEFILE_PATH)

# Code coverage tools
.PHONY: cov
cov:: $(INFO_FILES) | $(GCOV_PATH)
	$(GCOV)
	$(LCOV_FINAL)
	$(GENHTML)
	mv ./*.gcov ./coverage/gcov

$(LCOV_PATH)/%.info: $(OBJECT_PATH)/%.o | $(LCOV_PATH)
	$(LCOV)

# Generate documentation
.PHONY: doc
doc:: | $(DOXYGEN_PATH)
	$(DOXYGEN)

.PHONY: empty_target
empty_target::;

ifeq ($(PROJECT_TYPE),header)
.PHONY: header
header::;
endif

# Install everything
.PHONY: install
install:: all install_header install_lib

# Install header files
.PHONY: install_header
install_header:: all | $(HEADER_INSTALL_PATH)
	cp -r $(INC_PATH)/. $(HEADER_INSTALL_PATH)

# Install library files
.PHONY: install_lib
install_lib:: all | $(LIB_INSTALL_PATH)
	cp -ar $(BUILD_PATH)/* $(LIB_INSTALL_PATH)
	find $(EXTERNAL_LIB_PATH) -type f,l -exec cp -at $(LIB_INSTALL_PATH) {} +

# Build program
ifeq ($(PROJECT_TYPE),program)
.PHONY: program
program:: $(PROGRAM_TARGET)

$(PROGRAM_TARGET): $(OBJ_FILES) | $(BUILD_PATH)
	$(LINK_PROGRAM)
endif

# Remove existing build files and build again
.PHONY: rebuild
rebuild:: clean all

# Build project if not already built and run it
ifeq ($(PROJECT_TYPE),program)
RUN_CMD = $(PROGRAM_PATH)
.PHONY: run
run:: $(RUN_DEPS)
	$(RUN_CMD)
endif

ifeq ($(PROJECT_TYPE),$(findstring $(PROJECT_TYPE),shared static))
# Build shared library(.so)
.PHONY: shared
shared:: $(LIB_SHARED_TARGET)

$(LIB_SHARED_TARGET): $(OBJ_FILES) | $(BUILD_PATH)
	$(LINK_SHARED)
	ln -sf $(LIB_SHARED_XYZ) $(LIB_SHARED_X_PATH)
	ln -sf $(LIB_SHARED_X) $(LIB_SHARED_PATH)

# Build static library(.a)
.PHONY: static
static:: $(LIB_STATIC_TARGET)

$(LIB_STATIC_TARGET): $(OBJ_FILES) | $(BUILD_PATH)
	$(ARCHIVE)
endif

# Build tests if there is a test folder
ifneq ($(TEST_TARGET),empty_target)
.PHONY: $(TEST_TARGET)
$(TEST_TARGET):: test
.PHONY: test
test::
	$(MAKE) -C $(TEST_PATH) all CC=$(CC) BUILD_MODE=$(BUILD_MODE) \
	MAKEFILE_PATH=../$(MAKEFILE_PATH)
endif

# Uninstall everything
.PHONY: uninstall
uninstall::
	rm -rf $(HEADER_INSTALL_PATH)
	rm -rf $(LIB_INSTALL_PATH)

# Targets to create output directories
# mkdir -p: No error if directory exists and make parent directories as needed
$(ANALYSIS_PATH):       ;mkdir -p $(ANALYSIS_PATH)
$(BUILD_PATH):          ;mkdir -p $(BUILD_PATH)
$(CPPCHECK_PATH):       ;mkdir -p $(CPPCHECK_PATH)
$(DEP_PATH):            ;mkdir -p $(DEP_PATH)
$(DOXYGEN_PATH):        ;mkdir -p $(DOXYGEN_PATH)
$(GCOV_PATH):           ;mkdir -p $(GCOV_PATH)
$(HEADER_INSTALL_PATH): ;mkdir -p $(HEADER_INSTALL_PATH)
$(LIB_INSTALL_PATH):    ;mkdir -p $(LIB_INSTALL_PATH)
$(LCOV_PATH):           ;mkdir -p $(LCOV_PATH)
$(OBJ_PATH):            ;mkdir -p $(OBJ_PATH)
$(SCANBUILD_PATH):      ;mkdir -p $(SCANBUILD_PATH)
$(VALGRIND_PATH):       ;mkdir -p $(VALGRIND_PATH)
# Make each *.d file a target so make won't fail if the file doesn't exist
$(DEP_FILES):
# Only include *.d files if needed
ifneq ($(MAKECMDGOALS),$(findstring $(PROJECT_TYPE),clean doc header uninstall))
    include $(wildcard $(DEP_FILES))
endif
# Delete files generated by a target which failed(prevent corrupted files)
.DELETE_ON_ERROR:
